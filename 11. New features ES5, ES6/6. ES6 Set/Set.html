<!DOCTYPE html>
<html>
<head>
<title>Set.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="set">Set</h1>
<p><a href="https://xdevclass.com/tat-ca-nhung-gi-ban-can-biet-ve-map-va-set-trong-javascript/">Bài gốc: Tất cả những gì bạn cần biết về Map và Set trong Javascript</a></p>
<h2 id="set-l%C3%A0-g%C3%AC">Set là gì</h2>
<p><code>Set</code> là một tập hợp đặc biệt – “tập hợp các giá trị (value)” (không có key), nơi mà mỗi value chỉ có thể xuất hiện được một lần.</p>
<p>Các phương thức chính của nó:</p>
<ul>
<li><code>new Set(iterable)</code> – tạo set và nếu một <code>iterable</code> object được cung cấp (thường là một array), copy các giá trị từ nó vào set.</li>
<li><code>set.add(value)</code> – thêm một value, return về chính set đó</li>
<li><code>set.delete(value)</code> – xóa một value, return <code>true</code> nếu value tồn tại tại thời điểm gọi, không thì là <code>false</code>.</li>
<li><code>set.has(value)</code> – return <code>true</code> nếu value tồn tại trong set, không thì <code>false</code></li>
<li><code>set.clear()</code> – xóa mọi thứ từ set</li>
<li><code>set.size</code> – đếm số lượng phần tử</li>
</ul>
<p>Điều đặc biệt là khi gọi <code>set.add(value)</code> nhiều lần với cùng một value thì cũng không có tác dụng gì cả. Nguyên nhân là mỗi value chỉ được xuất hiện một lần trong Set.</p>
<p>Ví dụ, chúng ta có các vị khách đến thăm, chúng ta muốn ghi nhớ có bao nhiêu người riêng biệt. Nhưng nếu các vị khách đến thăm nhiều lần dễ dẫn đến chúng ta nhớ nhầm. Một vị khách nên được “tính” là một lần mà thôi.</p>
<p><code>Set</code> sinh ra để làm điều như vậy:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> <span class="hljs-keyword">set</span> = new Set()
let john = { name: <span class="hljs-string">'John'</span> }
<span class="hljs-keyword">let</span> pete = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Pete'</span> }
<span class="hljs-keyword">let</span> mary = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Mary'</span> }
<span class="hljs-comment">// Một số user đến thăm nhiều lần</span>
<span class="hljs-keyword">set</span>.add(john)
<span class="hljs-keyword">set</span>.add(pete)
<span class="hljs-keyword">set</span>.add(mary)
<span class="hljs-keyword">set</span>.add(john)
<span class="hljs-keyword">set</span>.add(mary)
// <span class="hljs-keyword">set</span> giữ cho value là duy nhất
alert(<span class="hljs-keyword">set</span>.size) // 3
for (let user of <span class="hljs-keyword">set</span>) {
  alert(user.name) <span class="hljs-comment">// John (sau đó là Pete và Mary)</span>
}
</div></code></pre>
<p>Một trường hợp thường dùng <code>Set</code> là loại bỏ các phần tử trùng lặp trong một mảng. Nếu theo những cách thông thường thì ta phải lặp qua các phần tử của mảng, nhưng cách này thì hiệu suất khá là tệ. <code>Set</code> mang đến một hiểu suất tốt hơn nhiều.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]
<span class="hljs-keyword">const</span> newArr = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr)) <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-keyword">const</span> newArr2 = [...new <span class="hljs-built_in">Set</span>(arr)] <span class="hljs-comment">// [1, 2, 3]</span>
</div></code></pre>
<h2 id="l%E1%BA%B7p-qua-set">Lặp qua Set</h2>
<p>Chúng ta có thể lặp qua một set với <code>for..of</code> hoặc sử dụng <code>forEach</code></p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> <span class="hljs-keyword">set</span> = new Set(['oranges', 'apples', 'bananas'])
for (let value of <span class="hljs-keyword">set</span>) alert(value)
// tương tự với forEach:
<span class="hljs-keyword">set</span>.forEach((value, valueAgain, <span class="hljs-keyword">set</span>) =&gt; {
  alert(value)
})
</div></code></pre>
<p>Để ý một điều hài hước là callback function được truyền vào <code>forEach</code> có 3 đối số: <code>value</code>, tiếp theo cũng là value nhưng với tên gọi khác là <code>valueAgain</code>, sau cùng là <code>object đích</code>. Thật vậy, cùng một giá trị nhưng lại xuất hiện 2 lần đối số.</p>
<p>Đó là để tương thích với <code>Map</code> khi mà callback được truyền trong <code>forEach</code> cũng có 3 đối số. Trông có vẻ lạ lạ nhưng để cho chắc chắn đó mà 😀 . Nó có thể giúp thay thế <code>Map</code> với <code>Set</code> lẫn nhau trong một số trường hợp nhất định hoặc ngược lại.</p>
<p>Một số phương thức tương tự như <code>Map</code> cũng được hỗ trợ</p>
<ul>
<li><code>set.keys()</code> – return một iterable object cho các value</li>
<li><code>set.values()</code> – giống như <code>set.keys()</code>, cho việc tương thích với <code>Map</code></li>
<li><code>set.entries()</code> – return một iterable object cho các entry <code>[value, value]</code>, cũng cho việc tương thích với <code>Map</code> luôn</li>
</ul>
<h2 id="t%C3%B3m-l%E1%BA%A1i">Tóm lại</h2>
<p><code>Map</code> là tập hợp các cặp value được định danh bằng key, các key có thể thuộc bất cứ kiểu dữ liệu nào.</p>
<p><code>Set</code> là tập hợp các value riêng biệt.</p>
<p>Việc lặp qua <code>Map</code> và <code>Set</code> thì luôn luôn được theo thứ tự, vì thế chúng ta không thể nói rằng những tập hợp các tập hợp này không được sắp xếp, nhưng chúng ta không thể sắp xếp lại các phần tử hoặc trực tiếp get một phần từ bằng vị trí thứ tự của nó.</p>
<h2 id="tham-kh%E1%BA%A3o">Tham khảo</h2>
<p>Bài viết được dịch từ <a href="https://javascript.info/map-set">Map and Set</a> tại <a href="https://javascript.info/">javascript.info</a></p>

</body>
</html>
